/*
Copyright 2021.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
	"context"

	kubetempurav1 "github.com/mercari/kubetempura/api/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"
)

// PRReconciler reconciles a PR object
type PRReconciler struct {
	client.Client
	Scheme *runtime.Scheme
}

//+kubebuilder:rbac:groups=kubetempura.mercari.com,resources=prs,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=kubetempura.mercari.com,resources=prs/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=kubetempura.mercari.com,resources=prs/finalizers,verbs=update
//+kubebuilder:rbac:groups=kubetempura.mercari.com,resources=reviewapps,verbs=get;list;watch
//+kubebuilder:rbac:groups=core,resources=configmaps,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=core,resources=secrets,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=core,resources=services,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=core,resources=services,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=apps,resources=deployments,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=networking.istio.io,resources=virtualservices,verbs=get;list;watch;create;update;patch;delete

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
func (r *PRReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	l := log.FromContext(ctx)
	l.Info("reconciling PR")

	pr := &kubetempurav1.PR{}
	err := r.Get(ctx, req.NamespacedName, pr)
	if err != nil {
		return ctrl.Result{}, client.IgnoreNotFound(err)
	}

	reviewApp := &kubetempurav1.ReviewApp{}
	err = r.Get(ctx, types.NamespacedName{Name: pr.Spec.ParentReviewApp, Namespace: pr.GetNamespace()}, reviewApp)
	if err != nil {
		l.Error(err, "Unable to load the ReviewApp")
		return ctrl.Result{}, err
	}

	vars := map[string]string{
		"PR_NUMBER":        pr.Spec.PRNumber,
		"COMMIT_REF":       pr.Spec.HeadCommitRef,
		"COMMIT_REF_SHORT": commitRefShort(pr.Spec.HeadCommitRef),
	}

	for _, resourceTemplate := range reviewApp.Spec.Resources {
		resource := applyTemplate(resourceTemplate, vars, pr.Spec.EnvVars)
		resource.SetNamespace(req.Namespace)
		rendered := *resource.DeepCopy()

		// TODO: So far, it doesn't support a case when ReviewApp updated and a child resource is removed from ReviewApp
		ret, err := ctrl.CreateOrUpdate(ctx, r.Client, &resource, func() error {
			resource.Object = mergeResourceConfigs(rendered, resource).Object
			return ctrl.SetControllerReference(pr, &resource, r.Scheme)
		})
		if err != nil {
			l.Error(err, "Unable to create or update the resource.", "ns", resource.GetNamespace(), "name", resource.GetName())
		} else {
			l.Info("Created or updated the resource.", "result", string(ret), "ns", resource.GetNamespace(), "name", resource.GetName())
		}
	}

	return ctrl.Result{}, nil
}

// SetupWithManager sets up the controller with the Manager.
func (r *PRReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&kubetempurav1.PR{}).
		Complete(r)
}

func commitRefShort(commitRefSha string) string {
	// replace COMMIT_REF_SHORT (first 7 chars of commit)
	//
	// Caveat: The length of the short ref generated by `git rev-parse --short` increases with the
	// number of commits in the source repository. The replacement here doesn't consider that and
	// always uses the first 7 characters of the commit hash.
	//
	// Fix: If your repository is large and it's short ref returned by git is longer than 7
	// characters, then switch to using COMMIT_REF when tagging Docker images.
	return commitRefSha[:7]
}
